<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pauker - SPA Start</title>
    <link rel="stylesheet" href="./index.css" />
  </head>
  <body>
    <div id="app-view">
      <div id="drawer-backdrop" class="drawer-backdrop"></div>

      <aside class="drawer" id="tree-drawer">
        <div id="drawer-resizer" class="drawer-resizer" aria-hidden="true"></div>
        <header class="drawer-header">
          <div class="drawer-title" id="drawer-title">DATABASE</div>
        </header>
        <div class="tree-scroll">
          <nav class="tree" id="tree-root" aria-label="Ordnerstruktur">
            <div style="padding: 1rem; color: hsl(var(--txt-muted));">Lade Ordnerstruktur...</div>
          </nav>
        </div>
      </aside>

      <main class="main-surface">
        <header class="top-bar">
          <button
            id="menu-tree-btn"
            class="menu-icon-btn"
            type="button"
            title="Ordnerstruktur ein-/ausblenden"
            aria-label="Ordnerstruktur ein-/ausblenden"
          >
            üìÅ
          </button>
          <div class="top-bar-title">Die Wiederholung ist die Mutter des Lernens</div>
          <button id="theme-toggle-app" class="theme-toggle-btn" type="button" aria-label="Theme wechseln">üåô</button>
        </header>
        <section id="content-host" class="content-host" aria-live="polite">
          <div class="content-placeholder">Klicke einen Endordner (üéÆ), um den C-Suite-Prototyp zu laden.</div>
        </section>
      </main>
    </div>

    <script>
      (function () {
        'use strict';

        const THEME_KEY = 'globalTheme_v1';
        const DRAWER_KEY = 'spaDrawerOpen_v1';
        const OPENED_KEY = 'spaOpenedFolders_v1';
        const DRAWER_WIDTH_KEY = 'spaDrawerWidth_v1';

        const appView = document.getElementById('app-view');
        const menuBtn = document.getElementById('menu-tree-btn');
        const themeToggleBtn = document.getElementById('theme-toggle-app');
        const drawerBackdrop = document.getElementById('drawer-backdrop');
        const treeDrawer = document.getElementById('tree-drawer');
        const drawerResizer = document.getElementById('drawer-resizer');
        const drawerTitleEl = document.getElementById('drawer-title');
        const treeRootEl = document.getElementById('tree-root');
        const contentHost = document.getElementById('content-host');

        let drawerOpen = false;
        let openedFolderIds = [];
        let drawerWidth = 360;
        let rootTree = [];

        init();

        function init() {
          loadState();
          initTheme();
          applyDrawerState();

          menuBtn.addEventListener('click', toggleDrawer);
          drawerBackdrop.addEventListener('click', () => setDrawer(false));
          themeToggleBtn.addEventListener('click', toggleTheme);
          initResizer();
          applyDrawerWidth();
          initGenericPageBridge();

          initIndex();
        }

        function initGenericPageBridge() {
          window.addEventListener('message', function (event) {
            const data = event && event.data;
            if (!data || typeof data !== 'object') return;

            if (data.type === 'global:theme:request') {
              replyThemeToMessageSource(event);
              return;
            }

            if (data.type !== 'generic:start-practice') return;

            const jsonUrl = typeof data.json === 'string' ? data.json : '';
            const folderLabel = typeof data.folder === 'string' ? data.folder : 'Spielordner';
            const gameUrl = typeof data.game === 'string' ? data.game : '';
            openPracticeView(gameUrl, jsonUrl, folderLabel);
          });
        }

        function getCurrentTheme() {
          return document.documentElement.classList.contains('theme-light') ? 'light' : 'dark';
        }

        function replyThemeToMessageSource(event) {
          if (!event || !event.source || typeof event.source.postMessage !== 'function') return;
          const targetOrigin = event.origin && event.origin !== 'null' ? event.origin : '*';
          event.source.postMessage({ type: 'global:theme', theme: getCurrentTheme() }, targetOrigin);
        }

        function loadState() {
          drawerOpen = localStorage.getItem(DRAWER_KEY) === '1';

          try {
            const raw = localStorage.getItem(OPENED_KEY);
            openedFolderIds = raw ? JSON.parse(raw) : [];
            if (!Array.isArray(openedFolderIds)) openedFolderIds = [];
          } catch (_) {
            openedFolderIds = [];
          }

          const rawWidth = Number(localStorage.getItem(DRAWER_WIDTH_KEY));
          if (!Number.isNaN(rawWidth) && rawWidth > 0) drawerWidth = rawWidth;
        }

        function saveState() {
          localStorage.setItem(DRAWER_KEY, drawerOpen ? '1' : '0');
          localStorage.setItem(OPENED_KEY, JSON.stringify(openedFolderIds));
          localStorage.setItem(DRAWER_WIDTH_KEY, String(drawerWidth));
        }

        function toggleDrawer() {
          setDrawer(!drawerOpen);
        }

        function setDrawer(nextOpen) {
          drawerOpen = !!nextOpen;
          saveState();
          applyDrawerState();
        }

        function applyDrawerState() {
          appView.classList.toggle('tree-open', drawerOpen);
          menuBtn.classList.toggle('active', drawerOpen);
          drawerBackdrop.classList.toggle('active', drawerOpen);
        }

        function clampDrawerWidth(width) {
          const min = 240;
          const max = Math.min(window.innerWidth * 0.88, 720);
          return Math.max(min, Math.min(max, width));
        }

        function applyDrawerWidth() {
          drawerWidth = clampDrawerWidth(drawerWidth);
          treeDrawer.style.setProperty('--drawer-width', drawerWidth + 'px');
        }

        function initResizer() {
          if (!drawerResizer) return;

          let isResizing = false;

          drawerResizer.addEventListener('mousedown', () => {
            isResizing = true;
            drawerResizer.classList.add('resizing');
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'col-resize';
          });

          window.addEventListener('mousemove', (event) => {
            if (!isResizing) return;
            drawerWidth = clampDrawerWidth(event.clientX);
            applyDrawerWidth();
          });

          window.addEventListener('mouseup', () => {
            if (!isResizing) return;
            isResizing = false;
            drawerResizer.classList.remove('resizing');
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
            saveState();
          });

          window.addEventListener('resize', applyDrawerWidth);
        }

        function initTheme() {
          const stored = localStorage.getItem(THEME_KEY);
          applyTheme(stored === 'light' ? 'light' : 'dark');
        }

        function toggleTheme() {
          const isLight = document.documentElement.classList.contains('theme-light');
          const next = isLight ? 'dark' : 'light';
          applyTheme(next);
          localStorage.setItem(THEME_KEY, next);
        }

        function applyTheme(theme) {
          if (theme === 'light') {
            document.documentElement.classList.add('theme-light');
            themeToggleBtn.textContent = '‚òÄÔ∏è';
            syncEmbeddedThemeToActiveFrame('light');
            return;
          }

          document.documentElement.classList.remove('theme-light');
          themeToggleBtn.textContent = 'üåô';
          syncEmbeddedThemeToActiveFrame('dark');
        }

        function syncEmbeddedThemeToActiveFrame(theme) {
          if (!contentHost) return;
          const frame = contentHost.querySelector('iframe.content-frame');
          if (!frame || !frame.contentWindow) return;
          frame.contentWindow.postMessage({ type: 'global:theme', theme: theme }, '*');
        }

        function queueThemeSyncForNewFrame() {
          const theme = getCurrentTheme();
          window.setTimeout(function () {
            syncEmbeddedThemeToActiveFrame(theme);
          }, 0);
          window.setTimeout(function () {
            syncEmbeddedThemeToActiveFrame(theme);
          }, 120);
        }

        async function initIndex() {
          try {
            const response = await fetch('./index.json?ts=' + Date.now());
            if (!response.ok) throw new Error('index.json konnte nicht geladen werden');

            const payload = await response.json();
            rootTree = normalizeTree(Array.isArray(payload.tree) ? payload.tree : []);
            drawerTitleEl.textContent = String(payload.rootName || 'DATABASE').toUpperCase();

            treeRootEl.innerHTML = '';
            buildTree(treeRootEl, rootTree, 0);
          } catch (error) {
            treeRootEl.innerHTML =
              '<div style="padding: 1rem; color: hsl(var(--txt-muted));">' +
              escapeHtml(error.message) +
              '</div>';
          }
        }

        function normalizeTree(nodes) {
          const folders = [];
          const dedupeMap = new Map();

          (Array.isArray(nodes) ? nodes : []).forEach((node) => {
            if (!node || !node.isFolder) return;

            const entries = normalizeNode(node);
            entries.forEach((entry) => {
              const key = canonicalName(entry.name);
              if (!dedupeMap.has(key)) {
                dedupeMap.set(key, entry);
                folders.push(entry);
                return;
              }

              const existing = dedupeMap.get(key);
              existing.children = mergeChildren(existing.children, entry.children);
              existing.hasFiles = existing.hasFiles || entry.hasFiles;
            });
          });

          return folders;
        }

        function normalizeNode(node) {
          const rawName = String(node.name || '');
          const cleanedName = decodeLegacyName(rawName);
          const rawChildren = Array.isArray(node.children) ? node.children : [];
          const normalizedChildren = normalizeTree(rawChildren);
          const hasFiles = rawChildren.some((child) => child && !child.isFolder);
          const jsonRelPath = findFirstJsonRelPath(rawChildren);
          const gameRelPath = findGameHtmlRelPath(rawChildren);

          if (cleanedName.toLowerCase() === 'database') return normalizedChildren;
          if (cleanedName === 'M') return normalizedChildren;
          if (/\bPr$/.test(cleanedName) && normalizedChildren.length > 0) return normalizedChildren;
          if (isLegacyArtifact(rawName, cleanedName)) return normalizedChildren;

          const normalizedNode = {
            id: node.id,
            name: cleanedName,
            isFolder: true,
            hasFiles: hasFiles,
            jsonRelPath: jsonRelPath,
            gameRelPath: gameRelPath,
            children: normalizedChildren
          };

          collapseNameFragments(normalizedNode);
          return [normalizedNode];
        }

        function collapseNameFragments(node) {
          while (node.children.length === 1) {
            const child = node.children[0];
            if (!child || !child.isFolder) break;
            if (!isLikelyNameFragment(child.name)) break;

            node.name = joinNameParts(node.name, child.name);
            node.children = child.children;
            node.hasFiles = node.hasFiles || child.hasFiles;
          }
        }

        function isLikelyNameFragment(name) {
          const value = String(name || '').trim();
          if (!value) return true;
          if (/^[&/]/.test(value)) return true;
          if (/^[√§√∂√º√ü]/i.test(value)) return true;
          return false;
        }

        function joinNameParts(left, right) {
          const a = String(left || '').trimEnd();
          const b = String(right || '').trimStart();

          if (!a) return b;
          if (!b) return a;
          if (b.startsWith('&') || b.startsWith('/')) return a + ' ' + b;
          if (/[A-Za-z√Ñ√ñ√ú√§√∂√º√ü]$/.test(a) && /^[a-z√§√∂√º√ü]/i.test(b)) return a + b;
          return a + ' ' + b;
        }

        function decodeLegacyName(raw) {
          return String(raw || '')
            .replace(/u([0-9a-fA-F]{4})/g, function (_, hex) {
              return String.fromCharCode(parseInt(hex, 16));
            })
            .replace(/\s+/g, ' ')
            .trim();
        }

        function isLegacyArtifact(rawName, cleanedName) {
          const raw = String(rawName || '').trim();
          const clean = String(cleanedName || '').trim();
          if (!raw && !clean) return true;
          if (/^[0-9]{3}([A-Za-z].*)?$/.test(raw)) return true;
          return false;
        }

        function canonicalName(value) {
          return String(value || '')
            .toLowerCase()
            .replace(/\s+/g, ' ')
            .trim();
        }

        function mergeChildren(baseChildren, addChildren) {
          const merged = [];
          const index = new Map();

          (Array.isArray(baseChildren) ? baseChildren : []).forEach((item) => {
            const key = canonicalName(item.name);
            index.set(key, item);
            merged.push(item);
          });

          (Array.isArray(addChildren) ? addChildren : []).forEach((item) => {
            const key = canonicalName(item.name);
            if (!index.has(key)) {
              index.set(key, item);
              merged.push(item);
              return;
            }

            const existing = index.get(key);
            existing.children = mergeChildren(existing.children, item.children);
            existing.hasFiles = existing.hasFiles || item.hasFiles;
            if (!existing.jsonRelPath && item.jsonRelPath) {
              existing.jsonRelPath = item.jsonRelPath;
            }
            if (!existing.gameRelPath && item.gameRelPath) {
              existing.gameRelPath = item.gameRelPath;
            }
          });

          return merged;
        }

        function buildTree(container, nodes, level) {
          nodes.forEach((node) => {
            if (!node || !node.isFolder) return;

            const rowNode = document.createElement('div');
            rowNode.className = 'tree-node';
            rowNode.dataset.id = node.id;

            const hasChildren = Array.isArray(node.children) && node.children.length > 0;
            const isCollapsed = !openedFolderIds.includes(node.id);
            rowNode.classList.toggle('tree-node--collapsed', isCollapsed);

            const row = document.createElement('div');
            row.className = 'tree-row';
            row.style.setProperty('--level', level);

            const iconButton = document.createElement('button');
            iconButton.className = 'tree-icon-button';
            iconButton.type = 'button';
            if (hasChildren) {
              iconButton.classList.add('is-toggleable');
              iconButton.setAttribute('aria-label', 'Ordner auf- oder zuklappen');
              iconButton.addEventListener('click', (event) => {
                event.stopPropagation();
                toggleNode(rowNode, node.id, iconButton);
              });
            } else {
              iconButton.setAttribute('aria-hidden', 'true');
              iconButton.tabIndex = -1;
            }

            const icon = document.createElement('span');
            icon.className = 'tree-icon';
            icon.textContent = folderEmoji(node, isCollapsed);
            iconButton.appendChild(icon);
            row.appendChild(iconButton);

            const label = document.createElement('button');
            label.className = 'tree-label';
            label.type = 'button';
            label.textContent = node.name;
            label.title = node.name;
            label.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (hasChildren) {
                toggleNode(rowNode, node.id, iconButton);
                return;
              }
              if (isPlayableFolder(node)) {
                openPlayableFolder(node);
              }
            });
            row.appendChild(label);

            rowNode.appendChild(row);

            const childContainer = document.createElement('div');
            childContainer.className = 'tree-children';
            if (Array.isArray(node.children) && node.children.length > 0) {
              buildTree(childContainer, node.children, level + 1);
            }
            rowNode.appendChild(childContainer);

            container.appendChild(rowNode);
          });
        }

        function toggleNode(rowNode, id, iconButton) {
          const idx = openedFolderIds.indexOf(id);
          if (idx >= 0) {
            openedFolderIds.splice(idx, 1);
            rowNode.classList.add('tree-node--collapsed');
          } else {
            openedFolderIds.push(id);
            rowNode.classList.remove('tree-node--collapsed');
          }

          const icon = iconButton && iconButton.querySelector('.tree-icon');
          if (icon) {
            const node = findNodeById(rootTree, id);
            icon.textContent = folderEmoji(node || { isFolder: true, hasFiles: false, children: [] }, !openedFolderIds.includes(id));
          }

          saveState();
        }

        function folderEmoji(node, isCollapsed) {
          const children = Array.isArray(node.children) ? node.children : [];
          const hasFolderChild = children.some((child) => child && child.isFolder);
          if (!hasFolderChild && node && node.gameRelPath) return 'üéÆ';
          return isCollapsed ? 'üìÅ' : 'üìÇ';
        }

        function findNodeById(nodes, id) {
          for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            if (node.id === id) return node;
            if (node.isFolder && Array.isArray(node.children)) {
              const found = findNodeById(node.children, id);
              if (found) return found;
            }
          }
          return null;
        }

        function isPlayableFolder(node) {
          return !!node && node.isFolder && !!node.hasFiles && (!!node.jsonRelPath || !!node.gameRelPath);
        }

        function openPlayableFolder(node) {
          if (!contentHost) return;
          const folderLabel = node && node.name ? node.name : 'Spielordner';
          const jsonRelPath = node && node.jsonRelPath ? String(node.jsonRelPath) : '';
          const gameRelPath = node && node.gameRelPath ? String(node.gameRelPath) : '';
          const jsonUrl = jsonRelPath ? new URL(jsonRelPath, window.location.href).href : '';
          const gameUrl = node && node.gameRelPath
            ? new URL(gameRelPath, window.location.href).href
            : '';
          const src = buildGenericPageSrc(folderLabel, jsonUrl, gameUrl, jsonRelPath, gameRelPath, node && node.id ? node.id : '');
          contentHost.innerHTML =
            '<iframe class="content-frame" src="' + src + '" title="C-Suite Prototyp" loading="eager"></iframe>';
          queueThemeSyncForNewFrame();
        }

        function buildGenericPageSrc(folderLabel, jsonUrl, gameUrl, jsonRelPath, gameRelPath, nodeId) {
          return (
            './generic_pages/generic_page.html?folder=' +
            encodeURIComponent(folderLabel) +
            '&json=' +
            encodeURIComponent(jsonUrl || '') +
            '&game=' +
            encodeURIComponent(gameUrl || '') +
            '&jsonRel=' +
            encodeURIComponent(jsonRelPath || '') +
            '&gameRel=' +
            encodeURIComponent(gameRelPath || '') +
            '&nodeId=' +
            encodeURIComponent(nodeId || '') +
            '&theme=' +
            encodeURIComponent(getCurrentTheme())
          );
        }

        function buildPracticeSrc(folderLabel, jsonUrl) {
          return (
            './generic_pages/generic_c_suite/generic_c_suite.html?folder=' +
            encodeURIComponent(folderLabel) +
            '&json=' +
            encodeURIComponent(jsonUrl) +
            '&theme=' +
            encodeURIComponent(getCurrentTheme())
          );
        }

        function openPracticeView(gameUrl, jsonUrl, folderLabel) {
          if (!contentHost) return;
          const safeGameUrl = String(gameUrl || '').trim();
          let src = safeGameUrl || buildPracticeSrc(folderLabel || 'Spielordner', jsonUrl || '');
          if (safeGameUrl) {
            try {
              const url = new URL(safeGameUrl, window.location.href);
              url.searchParams.set('theme', getCurrentTheme());
              src = url.href;
            } catch (_) {
              src = safeGameUrl;
            }
          }
          contentHost.innerHTML =
            '<iframe class="content-frame" src="' + src + '" title="C-Suite Prototyp" loading="eager"></iframe>';
          queueThemeSyncForNewFrame();
        }

        function findFirstJsonRelPath(children) {
          const g0Files = [];
          const otherJsonFiles = [];
          const files = Array.isArray(children) ? children : [];

          function collectJsonFiles(nodes) {
            const list = Array.isArray(nodes) ? nodes : [];
            for (let i = 0; i < list.length; i += 1) {
              const child = list[i];
              if (!child) continue;
              if (child.isFolder) {
                collectJsonFiles(child.children);
                continue;
              }
              const kind = String(child.kind || '').toLowerCase();
              const name = String(child.name || '').toLowerCase();
              if ((kind === 'json' || name.endsWith('.json')) && child.relPath) {
                if (/^_g0.+\.json$/i.test(name)) {
                  g0Files.push(child.relPath);
                } else {
                  otherJsonFiles.push(child.relPath);
                }
              }
            }
          }

          collectJsonFiles(files);
          if (g0Files.length) return g0Files[0];
          if (otherJsonFiles.length) return otherJsonFiles[0];
          return '';
        }

        function findGameHtmlRelPath(children) {
          const files = Array.isArray(children) ? children : [];
          const htmlFiles = [];

          function collectHtmlFiles(nodes) {
            const list = Array.isArray(nodes) ? nodes : [];
            list.forEach(function (child) {
              if (!child) return;
              if (child.isFolder) {
                collectHtmlFiles(child.children);
                return;
              }
              const kind = String(child.kind || '').toLowerCase();
              const name = String(child.name || '').toLowerCase();
              if (kind === 'html' || name.endsWith('.html')) {
                htmlFiles.push(child);
              }
            });
          }

          collectHtmlFiles(files);

          const preferred = htmlFiles.find(function (child) {
            const name = String(child.name || '').toLowerCase();
            return name.startsWith('_ghtml_') || name.startsWith('game_');
          }) || htmlFiles[0];

          return preferred && preferred.relPath ? preferred.relPath : '';
        }

        function escapeHtml(value) {
          return String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        }
      })();
    </script>
  </body>
</html>
