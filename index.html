<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pauker - SPA Start</title>
    <link rel="stylesheet" href="./index.css" />
  </head>
  <body>
    <div id="app-view">
      <div id="drawer-backdrop" class="drawer-backdrop"></div>

      <aside class="drawer" id="tree-drawer">
        <div id="drawer-resizer" class="drawer-resizer" aria-hidden="true"></div>
        <header class="drawer-header">
          <div class="drawer-title" id="drawer-title">DATABASE</div>
        </header>
        <div class="tree-scroll">
          <nav class="tree" id="tree-root" aria-label="Ordnerstruktur">
            <div style="padding: 1rem; color: hsl(var(--txt-muted));">Lade Ordnerstruktur...</div>
          </nav>
        </div>
      </aside>

      <main class="main-surface">
        <header class="top-bar">
          <button
            id="menu-tree-btn"
            class="menu-icon-btn"
            type="button"
            title="Ordnerstruktur ein-/ausblenden"
            aria-label="Ordnerstruktur ein-/ausblenden"
          >
            üìÅ
          </button>
          <div class="top-bar-title">Die Wiederholung ist die Mutter des Lernens</div>
          <button id="theme-toggle-app" class="theme-toggle-btn" type="button" aria-label="Theme wechseln">üåô</button>
        </header>
        <section id="content-host" class="content-host" aria-live="polite">
          <div class="content-placeholder">Klicke einen SpielButton im FolderTree, um die Spielseite zu laden.</div>
        </section>
      </main>
    </div>

    <script>
      (function () {
        'use strict';

        const THEME_KEY = 'globalTheme_v1';
        const DRAWER_KEY = 'spaDrawerOpen_v1';
        const OPENED_KEY = 'spaOpenedFolders_v1';
        const DRAWER_WIDTH_KEY = 'spaDrawerWidth_v1';
        const GAME_PROGRESS_KEY = 'spaGameProgress_v1';

        const appView = document.getElementById('app-view');
        const menuBtn = document.getElementById('menu-tree-btn');
        const themeToggleBtn = document.getElementById('theme-toggle-app');
        const drawerBackdrop = document.getElementById('drawer-backdrop');
        const treeDrawer = document.getElementById('tree-drawer');
        const drawerResizer = document.getElementById('drawer-resizer');
        const drawerTitleEl = document.getElementById('drawer-title');
        const treeRootEl = document.getElementById('tree-root');
        const contentHost = document.getElementById('content-host');

        let drawerOpen = false;
        let openedFolderIds = [];
        let drawerWidth = 360;
        let rootTree = [];
        let gameProgressByKey = {};
        let activeGameProgressContext = null;
        let activeGameProgressTimer = 0;

        init();

        function init() {
          loadState();
          initTheme();
          applyDrawerState();

          menuBtn.addEventListener('click', toggleDrawer);
          drawerBackdrop.addEventListener('click', () => setDrawer(false));
          themeToggleBtn.addEventListener('click', toggleTheme);
          initResizer();
          applyDrawerWidth();
          initGenericPageBridge();

          initIndex();
        }

        function initGenericPageBridge() {
          window.addEventListener('message', function (event) {
            const data = event && event.data;
            if (!data || typeof data !== 'object') return;

            if (data.type === 'global:theme:request') {
              replyThemeToMessageSource(event);
              return;
            }

            if (data.type === 'generic:game-state-snapshot') {
              handleGenericGameStateSnapshot(data);
              return;
            }

            if (data.type === 'generic:game-unmeasurable') {
              const progressKey = getProgressKeyFromMessage(data);
              if (progressKey) markGameProgressUnmeasurable(progressKey);
              return;
            }

            if (data.type !== 'generic:start-practice') return;

            const jsonUrl = typeof data.json === 'string' ? data.json : '';
            const folderLabel = typeof data.folder === 'string' ? data.folder : 'Spielordner';
            const gameUrl = typeof data.game === 'string' ? data.game : '';
            const progressKey = getProgressKeyFromMessage(data) || inferProgressKeyFromUrls(gameUrl, jsonUrl);
            openPracticeView(gameUrl, jsonUrl, folderLabel, progressKey);
          });
        }

        function getCurrentTheme() {
          return document.documentElement.classList.contains('theme-light') ? 'light' : 'dark';
        }

        function replyThemeToMessageSource(event) {
          if (!event || !event.source || typeof event.source.postMessage !== 'function') return;
          const targetOrigin = event.origin && event.origin !== 'null' ? event.origin : '*';
          event.source.postMessage({ type: 'global:theme', theme: getCurrentTheme() }, targetOrigin);
        }

        function loadState() {
          drawerOpen = localStorage.getItem(DRAWER_KEY) === '1';

          try {
            const raw = localStorage.getItem(OPENED_KEY);
            openedFolderIds = raw ? JSON.parse(raw) : [];
            if (!Array.isArray(openedFolderIds)) openedFolderIds = [];
          } catch (_) {
            openedFolderIds = [];
          }

          const rawWidth = Number(localStorage.getItem(DRAWER_WIDTH_KEY));
          if (!Number.isNaN(rawWidth) && rawWidth > 0) drawerWidth = rawWidth;

          try {
            const rawProgress = localStorage.getItem(GAME_PROGRESS_KEY);
            const parsed = rawProgress ? JSON.parse(rawProgress) : {};
            gameProgressByKey = sanitizeProgressStore(parsed);
          } catch (_) {
            gameProgressByKey = {};
          }
        }

        function saveState() {
          localStorage.setItem(DRAWER_KEY, drawerOpen ? '1' : '0');
          localStorage.setItem(OPENED_KEY, JSON.stringify(openedFolderIds));
          localStorage.setItem(DRAWER_WIDTH_KEY, String(drawerWidth));
          localStorage.setItem(GAME_PROGRESS_KEY, JSON.stringify(gameProgressByKey));
        }

        function toggleDrawer() {
          setDrawer(!drawerOpen);
        }

        function setDrawer(nextOpen) {
          drawerOpen = !!nextOpen;
          saveState();
          applyDrawerState();
        }

        function applyDrawerState() {
          appView.classList.toggle('tree-open', drawerOpen);
          menuBtn.classList.toggle('active', drawerOpen);
          drawerBackdrop.classList.toggle('active', drawerOpen);
        }

        function clampDrawerWidth(width) {
          const min = 320;
          const max = window.innerWidth;
          return Math.max(min, Math.min(max, width));
        }

        function applyDrawerWidth() {
          drawerWidth = clampDrawerWidth(drawerWidth);
          treeDrawer.style.setProperty('--drawer-width', drawerWidth + 'px');
        }

        function initResizer() {
          if (!drawerResizer) return;

          let isResizing = false;

          drawerResizer.addEventListener('mousedown', () => {
            isResizing = true;
            drawerResizer.classList.add('resizing');
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'col-resize';
          });

          window.addEventListener('mousemove', (event) => {
            if (!isResizing) return;
            drawerWidth = clampDrawerWidth(event.clientX);
            applyDrawerWidth();
          });

          window.addEventListener('mouseup', () => {
            if (!isResizing) return;
            isResizing = false;
            drawerResizer.classList.remove('resizing');
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
            saveState();
          });

          window.addEventListener('resize', applyDrawerWidth);
        }

        function initTheme() {
          const stored = localStorage.getItem(THEME_KEY);
          applyTheme(stored === 'light' ? 'light' : 'dark');
        }

        function toggleTheme() {
          const isLight = document.documentElement.classList.contains('theme-light');
          const next = isLight ? 'dark' : 'light';
          applyTheme(next);
          localStorage.setItem(THEME_KEY, next);
        }

        function applyTheme(theme) {
          if (theme === 'light') {
            document.documentElement.classList.add('theme-light');
            themeToggleBtn.textContent = '‚òÄÔ∏è';
            syncEmbeddedThemeToActiveFrame('light');
            return;
          }

          document.documentElement.classList.remove('theme-light');
          themeToggleBtn.textContent = 'üåô';
          syncEmbeddedThemeToActiveFrame('dark');
        }

        function syncEmbeddedThemeToActiveFrame(theme) {
          if (!contentHost) return;
          const frame = contentHost.querySelector('iframe.content-frame');
          if (!frame || !frame.contentWindow) return;
          frame.contentWindow.postMessage({ type: 'global:theme', theme: theme }, '*');
        }

        function queueThemeSyncForNewFrame() {
          const theme = getCurrentTheme();
          window.setTimeout(function () {
            syncEmbeddedThemeToActiveFrame(theme);
          }, 0);
          window.setTimeout(function () {
            syncEmbeddedThemeToActiveFrame(theme);
          }, 120);
        }

        function normalizeProgressKey(rawKey) {
          return String(rawKey || '').trim();
        }

        function clampPercent(value) {
          const numeric = Number(value);
          if (!Number.isFinite(numeric)) return 0;
          if (numeric <= 0) return 0;
          if (numeric >= 100) return 100;
          return Math.round(numeric);
        }

        function sanitizeProgressStore(rawStore) {
          const input = rawStore && typeof rawStore === 'object' ? rawStore : {};
          const out = {};
          Object.keys(input).forEach(function (sourceKey) {
            const key = normalizeProgressKey(sourceKey);
            if (!key) return;
            const entry = input[sourceKey];
            const isObj = entry && typeof entry === 'object';
            const percent = isObj ? clampPercent(entry.percent) : clampPercent(entry);
            const measurable = !(isObj && entry.measurable === false);
            const updatedAt = isObj && Number.isFinite(Number(entry.updatedAt))
              ? Number(entry.updatedAt)
              : Date.now();
            out[key] = {
              percent: percent,
              measurable: measurable,
              updatedAt: updatedAt
            };
          });
          return out;
        }

        function buildNodeProgressKey(node) {
          if (!node) return '';
          return normalizeProgressKey(
            String(node.gameRelPath || node.jsonRelPath || node.attributesRelPath || node.id || '')
          );
        }

        function getProgressKeyFromMessage(data) {
          const payload = data && typeof data === 'object' ? data : {};
          return normalizeProgressKey(
            String(payload.progressKey || payload.gameRel || payload.jsonRel || payload.nodeId || '')
          );
        }

        function inferRepoPathFromUrl(urlValue) {
          const source = String(urlValue || '').trim();
          if (!source) return '';
          try {
            const parsed = new URL(source, window.location.href);
            return decodeURIComponent(parsed.pathname).replace(/^\/+/, '');
          } catch (_) {
            return '';
          }
        }

        function inferProgressKeyFromUrls(gameUrl, jsonUrl) {
          const gamePath = normalizeProgressKey(inferRepoPathFromUrl(gameUrl));
          if (gamePath) return gamePath;
          return normalizeProgressKey(inferRepoPathFromUrl(jsonUrl));
        }

        function getProgressEntry(progressKey) {
          const key = normalizeProgressKey(progressKey);
          if (!key) return null;
          const entry = gameProgressByKey[key];
          if (!entry || typeof entry !== 'object') return null;
          return entry;
        }

        function setGameProgress(progressKey, percentValue, measurable) {
          const key = normalizeProgressKey(progressKey);
          if (!key) return;
          const nextPercent = clampPercent(percentValue);
          const prev = getProgressEntry(key);
          const nextMeasurable = measurable === false ? false : true;
          const prevPercent = prev ? clampPercent(prev.percent) : -1;
          const prevMeasurable = prev ? prev.measurable !== false : true;
          if (prevPercent === nextPercent && prevMeasurable === nextMeasurable) return;
          gameProgressByKey[key] = {
            percent: nextPercent,
            measurable: nextMeasurable,
            updatedAt: Date.now()
          };
          saveState();
          updateTreeProgressBadges();
        }

        function markGameProgressUnmeasurable(progressKey) {
          const key = normalizeProgressKey(progressKey);
          if (!key) return;
          const prev = getProgressEntry(key);
          const nextPercent = prev ? clampPercent(prev.percent) : 0;
          if (prev && prev.measurable === false && clampPercent(prev.percent) === nextPercent) return;
          gameProgressByKey[key] = {
            percent: nextPercent,
            measurable: false,
            updatedAt: Date.now()
          };
          saveState();
          updateTreeProgressBadges();
        }

        function handleGenericGameStateSnapshot(data) {
          const progressKey = getProgressKeyFromMessage(data);
          if (!progressKey) return;
          const estimation = estimateProgressFromStateText(data.stateText);
          if (!estimation.measurable) {
            markGameProgressUnmeasurable(progressKey);
            return;
          }
          setGameProgress(progressKey, estimation.percent, true);
        }

        function buildNodeProgressMap(nodes) {
          const map = new Map();

          function visit(node) {
            if (!node || !node.isFolder) return { sum: 0, count: 0 };

            if (isGameLaunchNode(node)) {
              const entry = getProgressEntry(buildNodeProgressKey(node));
              const percent = entry ? clampPercent(entry.percent) : 0;
              map.set(node.id, percent);
              return { sum: percent, count: 1 };
            }

            const children = Array.isArray(node.children) ? node.children : [];
            let sum = 0;
            let count = 0;
            for (let i = 0; i < children.length; i += 1) {
              const childResult = visit(children[i]);
              sum += childResult.sum;
              count += childResult.count;
            }

            if (count === 0 && isPlayableFolder(node)) {
              const ownEntry = getProgressEntry(buildNodeProgressKey(node));
              const ownPercent = ownEntry ? clampPercent(ownEntry.percent) : 0;
              map.set(node.id, ownPercent);
              return { sum: ownPercent, count: 1 };
            }

            const folderPercent = count > 0 ? Math.round(sum / count) : 0;
            map.set(node.id, clampPercent(folderPercent));
            return { sum: sum, count: count };
          }

          const list = Array.isArray(nodes) ? nodes : [];
          for (let i = 0; i < list.length; i += 1) visit(list[i]);

          return map;
        }

        function updateTreeProgressBadges() {
          if (!treeRootEl) return;
          const progressMap = buildNodeProgressMap(rootTree);
          const nodeElements = treeRootEl.querySelectorAll('.tree-node[data-id]');
          nodeElements.forEach(function (rowNode) {
            const id = String(rowNode.dataset.id || '');
            if (!id) return;
            const badge = rowNode.querySelector('.tree-meta-cell--progress');
            if (!badge) return;
            const percent = clampPercent(progressMap.has(id) ? progressMap.get(id) : 0);
            badge.textContent = percent + '%';
            badge.title = 'Fortschritt: ' + percent + '%';
          });
        }

        function estimateProgressFromStateText(stateText) {
          if (stateText === null || stateText === undefined) return { measurable: false, percent: 0 };

          if (typeof stateText === 'number') {
            return { measurable: true, percent: normalizeProgressNumber(stateText) };
          }

          const rawText = String(stateText || '').trim();
          if (!rawText) return { measurable: false, percent: 0 };

          try {
            const parsed = JSON.parse(rawText);
            return estimateProgressFromPayload(parsed);
          } catch (_) {
            const byText = rawText.match(/([0-9]{1,3})\s*%/);
            if (byText) return { measurable: true, percent: clampPercent(Number(byText[1])) };
            return { measurable: false, percent: 0 };
          }
        }

        function normalizeProgressNumber(value) {
          const n = Number(value);
          if (!Number.isFinite(n)) return 0;
          if (n >= 0 && n <= 1) return clampPercent(n * 100);
          return clampPercent(n);
        }

        function estimateProgressFromPayload(payload) {
          const percentSignals = [];
          const ratioSignals = [];
          let hasCompletionFlag = false;

          function visit(value, keyPath) {
            if (value === null || value === undefined) return;

            if (typeof value === 'number' && Number.isFinite(value)) {
              const pathLower = String(keyPath || '').toLowerCase();
              if (/(progress|fortschritt|percent|percentage|completion|completed|erledigt|abgeschlossen)/.test(pathLower)) {
                percentSignals.push(normalizeProgressNumber(value));
              }
              return;
            }

            if (typeof value === 'boolean') {
              if (value && /(won|win|complete|completed|finished|done|success|cleared|abgeschlossen|beendet|geloest|gel√∂st)/i.test(String(keyPath || ''))) {
                hasCompletionFlag = true;
              }
              return;
            }

            if (Array.isArray(value)) {
              for (let i = 0; i < value.length; i += 1) {
                visit(value[i], String(keyPath || '') + '[' + i + ']');
              }
              return;
            }

            if (typeof value === 'object') {
              const ratio = extractRatioProgressFromObject(value);
              if (ratio !== null) ratioSignals.push(ratio);
              const entries = Object.entries(value);
              for (let i = 0; i < entries.length; i += 1) {
                const item = entries[i];
                const nestedPath = keyPath ? keyPath + '.' + item[0] : item[0];
                visit(item[1], nestedPath);
              }
            }
          }

          visit(payload, '');

          if (percentSignals.length) {
            const avg = percentSignals.reduce((sum, val) => sum + val, 0) / percentSignals.length;
            return { measurable: true, percent: clampPercent(avg) };
          }

          if (ratioSignals.length) {
            const avgRatio = ratioSignals.reduce((sum, val) => sum + val, 0) / ratioSignals.length;
            return { measurable: true, percent: clampPercent(avgRatio) };
          }

          if (hasCompletionFlag) return { measurable: true, percent: 100 };

          return { measurable: false, percent: 0 };
        }

        function extractRatioProgressFromObject(obj) {
          if (!obj || typeof obj !== 'object') return null;
          const entries = Object.entries(obj).filter(function (entry) {
            return typeof entry[1] === 'number' && Number.isFinite(entry[1]);
          });
          if (!entries.length) return null;

          const totals = entries.filter(function (entry) {
            return /(total|max|maximum|target|ziel|gesamt)/i.test(entry[0]) && entry[1] > 0;
          });
          if (!totals.length) return null;

          const currents = entries.filter(function (entry) {
            return /(current|done|completed|solved|answered|score|step|round|level|index|fortschritt|progress)/i.test(entry[0]) && entry[1] >= 0;
          });
          if (!currents.length) return null;

          let best = null;
          for (let i = 0; i < totals.length; i += 1) {
            const totalValue = totals[i][1];
            if (!(totalValue > 0)) continue;
            for (let j = 0; j < currents.length; j += 1) {
              const currentValue = currents[j][1];
              if (currentValue < 0) continue;
              const ratio = clampPercent((currentValue / totalValue) * 100);
              if (best === null || ratio > best) best = ratio;
            }
          }
          return best;
        }

        function readGameStateFromWindow(contentWindow) {
          if (!contentWindow) return { kind: 'no-window' };
          try {
            if (typeof contentWindow.render_game_to_text !== 'function') return { kind: 'no-hook' };
            const stateText = contentWindow.render_game_to_text();
            if (stateText === null || stateText === undefined || String(stateText).trim() === '') {
              return { kind: 'no-state' };
            }
            return { kind: 'state', stateText: String(stateText) };
          } catch (_) {
            return { kind: 'error' };
          }
        }

        function stopActiveGameProgressTracking() {
          if (activeGameProgressTimer) {
            window.clearInterval(activeGameProgressTimer);
            activeGameProgressTimer = 0;
          }
          activeGameProgressContext = null;
        }

        function startActiveGameProgressTracking(progressKey) {
          const key = normalizeProgressKey(progressKey);
          stopActiveGameProgressTracking();
          if (!key) return;

          activeGameProgressContext = {
            progressKey: key,
            noHookHits: 0
          };

          function tick() {
            if (!activeGameProgressContext || !contentHost) return;
            const frameEl = contentHost.querySelector('iframe.content-frame');
            if (!frameEl || !frameEl.contentWindow) return;

            const sample = readGameStateFromWindow(frameEl.contentWindow);
            if (sample.kind === 'state') {
              activeGameProgressContext.noHookHits = 0;
              const estimation = estimateProgressFromStateText(sample.stateText);
              if (estimation.measurable) {
                setGameProgress(activeGameProgressContext.progressKey, estimation.percent, true);
              }
              return;
            }

            if (sample.kind === 'no-hook' || sample.kind === 'no-state') {
              activeGameProgressContext.noHookHits += 1;
              if (activeGameProgressContext.noHookHits >= 3) {
                markGameProgressUnmeasurable(activeGameProgressContext.progressKey);
              }
              return;
            }
          }

          activeGameProgressTimer = window.setInterval(tick, 1400);
          window.setTimeout(tick, 450);
          window.setTimeout(tick, 1400);
        }

        async function initIndex() {
          try {
            renderTreeLoadingState(0, 'Lade Ordnerstruktur...');
            const response = await fetch('./index.json?ts=' + Date.now());
            if (!response.ok) throw new Error('index.json konnte nicht geladen werden');

            const payload = await response.json();
            rootTree = normalizeTree(Array.isArray(payload.tree) ? payload.tree : []);
            drawerTitleEl.textContent = '';

            const iconTargets = collectIconTargetNodes(rootTree);
            if (iconTargets.length > 0) {
              renderTreeLoadingState(0, 'Lade Icon-Metadaten...');
              await hydrateTreeIcons(iconTargets, function (done, total) {
                const ratio = total > 0 ? done / total : 1;
                renderTreeLoadingState(ratio, 'Lade Icon-Metadaten...');
              });
            }

            treeRootEl.innerHTML = '';
            const progressMap = buildNodeProgressMap(rootTree);
            treeRootEl.appendChild(buildTreeMetaHeaderRow());
            const treeList = document.createElement('div');
            treeList.className = 'tree-list';
            buildTree(treeList, rootTree, 0, progressMap);
            treeRootEl.appendChild(treeList);
          } catch (error) {
            treeRootEl.innerHTML =
              '<div style="padding: 1rem; color: hsl(var(--txt-muted));">' +
              escapeHtml(error.message) +
              '</div>';
          }
        }

        function renderTreeLoadingState(progress, label) {
          const ratio = Math.max(0, Math.min(1, Number(progress) || 0));
          const percent = Math.round(ratio * 100);
          treeRootEl.innerHTML =
            '<div class="tree-loading">' +
            '<div class="tree-loading-title">' +
            escapeHtml(label || 'Ladevorgang...') +
            '</div>' +
            '<div class="tree-loading-track">' +
            '<div class="tree-loading-fill" style="width:' +
            percent +
            '%"></div>' +
            '</div>' +
            '<div class="tree-loading-meta">' +
            percent +
            '%</div>' +
            '</div>';
        }

        function buildTreeMetaHeaderRow() {
          const row = document.createElement('div');
          row.className = 'tree-meta-header';

          const probabilityCol = document.createElement('span');
          probabilityCol.className = 'tree-meta-head-cell tree-meta-head-icon';
          probabilityCol.textContent = 'üî•';
          probabilityCol.dataset.tooltip = 'Thema ist zu x% in vergangenen Pr√ºfungen erschienen.';
          probabilityCol.setAttribute('aria-label', 'Thema ist zu x% in vergangenen Pr√ºfungen erschienen.');
          probabilityCol.tabIndex = 0;
          row.appendChild(probabilityCol);

          const progressCol = document.createElement('span');
          progressCol.className = 'tree-meta-head-cell tree-meta-head-icon';
          progressCol.textContent = 'üß†';
          progressCol.dataset.tooltip = 'Fortschritt';
          progressCol.setAttribute('aria-label', 'Fortschritt');
          progressCol.tabIndex = 0;
          row.appendChild(progressCol);

          const spacer = document.createElement('span');
          spacer.className = 'tree-meta-head-spacer';
          spacer.setAttribute('aria-hidden', 'true');
          row.appendChild(spacer);

          return row;
        }

        function collectIconTargetNodes(nodes, bucket) {
          const out = Array.isArray(bucket) ? bucket : [];
          (Array.isArray(nodes) ? nodes : []).forEach((node) => {
            if (!node || !node.isFolder) return;
            const children = Array.isArray(node.children) ? node.children : [];
            if (isGameLaunchNode(node)) {
              out.push(node);
            }
            collectIconTargetNodes(children, out);
          });
          return out;
        }

        async function hydrateTreeIcons(iconNodes, onProgress) {
          const nodes = Array.isArray(iconNodes) ? iconNodes : [];
          const uniquePaths = [];
          const seen = new Set();

          nodes.forEach((node) => {
            const relPath = String(node && node.attributesRelPath ? node.attributesRelPath : '').trim();
            if (!relPath || seen.has(relPath)) return;
            seen.add(relPath);
            uniquePaths.push(relPath);
          });

          if (!uniquePaths.length) {
            nodes.forEach((node) => {
              node.icon = resolveFolderIcon(node.jsonRelPath, node.gameRelPath);
            });
            if (typeof onProgress === 'function') onProgress(1, 1);
            return;
          }

          const iconByPath = new Map();
          let done = 0;
          await Promise.all(
            uniquePaths.map(async (relPath) => {
              const icon = await fetchIconFromAttributes(relPath);
              iconByPath.set(relPath, icon);
              done += 1;
              if (typeof onProgress === 'function') onProgress(done, uniquePaths.length);
            })
          );

          nodes.forEach((node) => {
            const relPath = String(node && node.attributesRelPath ? node.attributesRelPath : '').trim();
            const loadedIcon = normalizeIconValue(iconByPath.get(relPath));
            node.icon = loadedIcon || resolveFolderIcon(node.jsonRelPath, node.gameRelPath);
          });
        }

        async function fetchIconFromAttributes(relPath) {
          const cleanPath = String(relPath || '').trim();
          if (!cleanPath) return '';

          try {
            const baseUrl = buildRepoUrl(cleanPath);
            if (!baseUrl) return '';
            const url = new URL(baseUrl);
            url.searchParams.set('ts', String(Date.now()));
            const response = await fetch(url.href);
            if (!response.ok) return '';
            const payload = await response.json();
            if (!payload || typeof payload !== 'object') return '';
            if (typeof payload.Icon === 'string') return payload.Icon;
            if (typeof payload.icon === 'string') return payload.icon;
            return '';
          } catch (_) {
            return '';
          }
        }

        function normalizeIconValue(rawIcon) {
          const value = String(rawIcon || '').trim().toLowerCase();
          if (!value) return '';
          if (value === 'flame' || value === 'fire' || value === 'üî•') return 'flame';
          if (value === 'books' || value === 'book' || value === 'üìö') return 'books';
          if (value === 'brain' || value === 'üß†') return 'books';
          return '';
        }

        function safeDecodePathPart(value) {
          const source = String(value || '');
          try {
            return decodeURIComponent(source);
          } catch (_) {
            return source;
          }
        }

        function buildRepoUrl(relPath) {
          const source = String(relPath || '').trim();
          if (!source) return '';
          const encodedPath = source
            .split('/')
            .map((segment) => encodeURIComponent(safeDecodePathPart(segment)))
            .join('/');
          return new URL(encodedPath, window.location.href).href;
        }

        function normalizeFolderNameKey(value) {
          return String(value || '')
            .trim()
            .toLowerCase();
        }

        function isHiddenFolderName(rawName, cleanedName) {
          const raw = String(rawName || '').trim();
          const clean = String(cleanedName || '').trim();
          const key = normalizeFolderNameKey(clean || raw);
          if (!key) return false;
          if (raw.startsWith('_') || clean.startsWith('_')) return true;
          return false;
        }

        function normalizeTree(nodes) {
          const folders = [];
          const dedupeMap = new Map();

          (Array.isArray(nodes) ? nodes : []).forEach((node) => {
            if (!node || !node.isFolder) return;

            const entries = normalizeNode(node);
            entries.forEach((entry) => {
              const key = canonicalName(entry.name);
              if (!dedupeMap.has(key)) {
                dedupeMap.set(key, entry);
                folders.push(entry);
                return;
              }

              const existing = dedupeMap.get(key);
              existing.children = mergeChildren(existing.children, entry.children);
              existing.hasFiles = existing.hasFiles || entry.hasFiles;
            });
          });

          return folders;
        }

        function normalizeNode(node) {
          const rawName = String(node.name || '');
          const cleanedName = decodeLegacyName(rawName);
          if (isHiddenFolderName(rawName, cleanedName)) return [];

          const rawChildren = Array.isArray(node.children) ? node.children : [];
          const normalizedChildren = normalizeTree(rawChildren);
          const hasFiles = rawChildren.some((child) => child && !child.isFolder);
          const jsonRelPath = findFirstJsonRelPath(rawChildren);
          const gameRelPath = findGameHtmlRelPath(rawChildren);
          const attributesRelPath = findAttributesRelPath(rawChildren);

          if (cleanedName.toLowerCase() === 'database') return normalizedChildren;
          if (cleanedName === 'M') return normalizedChildren;
          if (/\bPr$/.test(cleanedName) && normalizedChildren.length > 0) return normalizedChildren;
          if (isLegacyArtifact(rawName, cleanedName)) return normalizedChildren;

          const normalizedNode = {
            id: node.id,
            name: cleanedName,
            isFolder: true,
            hasFiles: hasFiles,
            jsonRelPath: jsonRelPath,
            gameRelPath: gameRelPath,
            attributesRelPath: attributesRelPath,
            icon: resolveFolderIcon(jsonRelPath, gameRelPath),
            children: normalizedChildren
          };

          collapseNameFragments(normalizedNode);
          return [normalizedNode];
        }

        function collapseNameFragments(node) {
          while (node.children.length === 1) {
            const child = node.children[0];
            if (!child || !child.isFolder) break;
            if (!isLikelyNameFragment(child.name)) break;

            node.name = joinNameParts(node.name, child.name);
            node.children = child.children;
            node.hasFiles = node.hasFiles || child.hasFiles;
            if (!node.jsonRelPath && child.jsonRelPath) node.jsonRelPath = child.jsonRelPath;
            if (!node.gameRelPath && child.gameRelPath) node.gameRelPath = child.gameRelPath;
            if (!node.attributesRelPath && child.attributesRelPath) node.attributesRelPath = child.attributesRelPath;
            if (!node.icon && child.icon) node.icon = child.icon;
          }
        }

        function isLikelyNameFragment(name) {
          const value = String(name || '').trim();
          if (!value) return true;
          if (/^[&/]/.test(value)) return true;
          if (/^[√§√∂√º√ü]/i.test(value)) return true;
          return false;
        }

        function joinNameParts(left, right) {
          const a = String(left || '').trimEnd();
          const b = String(right || '').trimStart();

          if (!a) return b;
          if (!b) return a;
          if (b.startsWith('&') || b.startsWith('/')) return a + ' ' + b;
          if (/[A-Za-z√Ñ√ñ√ú√§√∂√º√ü]$/.test(a) && /^[a-z√§√∂√º√ü]/i.test(b)) return a + b;
          return a + ' ' + b;
        }

        function decodeLegacyName(raw) {
          return String(raw || '')
            .replace(/u([0-9a-fA-F]{4})/g, function (_, hex) {
              return String.fromCharCode(parseInt(hex, 16));
            })
            .replace(/\s+/g, ' ')
            .trim();
        }

        function isLegacyArtifact(rawName, cleanedName) {
          const raw = String(rawName || '').trim();
          const clean = String(cleanedName || '').trim();
          if (!raw && !clean) return true;
          if (/^[0-9]{3}([A-Za-z].*)?$/.test(raw)) return true;
          return false;
        }

        function canonicalName(value) {
          return String(value || '')
            .toLowerCase()
            .replace(/\s+/g, ' ')
            .trim();
        }

        function mergeChildren(baseChildren, addChildren) {
          const merged = [];
          const index = new Map();

          (Array.isArray(baseChildren) ? baseChildren : []).forEach((item) => {
            const key = canonicalName(item.name);
            index.set(key, item);
            merged.push(item);
          });

          (Array.isArray(addChildren) ? addChildren : []).forEach((item) => {
            const key = canonicalName(item.name);
            if (!index.has(key)) {
              index.set(key, item);
              merged.push(item);
              return;
            }

            const existing = index.get(key);
            existing.children = mergeChildren(existing.children, item.children);
            existing.hasFiles = existing.hasFiles || item.hasFiles;
            if (!existing.jsonRelPath && item.jsonRelPath) {
              existing.jsonRelPath = item.jsonRelPath;
            }
            if (!existing.gameRelPath && item.gameRelPath) {
              existing.gameRelPath = item.gameRelPath;
            }
            if (!existing.attributesRelPath && item.attributesRelPath) {
              existing.attributesRelPath = item.attributesRelPath;
            }
            if (!existing.icon && item.icon) {
              existing.icon = item.icon;
            }
          });

          return merged;
        }

        function buildTree(container, nodes, level, progressMap) {
          nodes.forEach((node) => {
            if (!node || !node.isFolder) return;

            const rowNode = document.createElement('div');
            rowNode.className = 'tree-node';
            rowNode.dataset.id = node.id;

            const hasChildren = Array.isArray(node.children) && node.children.length > 0;
            const canOpenPlayable = isPlayableFolder(node);
            const isGameNode = isGameLaunchNode(node);
            const isCollapsed = !openedFolderIds.includes(node.id);
            rowNode.classList.toggle('tree-node--collapsed', isCollapsed);

            const row = document.createElement('div');
            row.className = 'tree-row';
            row.style.setProperty('--level', level);

            const probabilityPercent = resolveExamProbabilityPercent(node);
            const probabilityCell = document.createElement('span');
            probabilityCell.className = 'tree-meta-cell tree-meta-cell--probability';
            if (isGameNode) {
              probabilityCell.textContent = '';
              probabilityCell.setAttribute('aria-label', '');
            } else {
              probabilityCell.textContent = probabilityPercent + '%';
            }
            row.appendChild(probabilityCell);

            const progressValue = clampPercent(
              progressMap && progressMap.has(node.id) ? progressMap.get(node.id) : 0
            );
            const progressCell = document.createElement('span');
            progressCell.className = 'tree-meta-cell tree-meta-cell--progress';
            progressCell.textContent = progressValue + '%';
            row.appendChild(progressCell);

            const treeMain = document.createElement('div');
            treeMain.className = 'tree-main';

            const label = document.createElement('button');
            label.className = 'tree-label';
            label.type = 'button';
            label.title = node.name;

            const labelIcon = document.createElement('span');
            labelIcon.className = 'tree-label-icon';
            labelIcon.textContent = folderEmoji(node, isCollapsed);
            label.appendChild(labelIcon);

            if (hasChildren) {
              labelIcon.classList.add('tree-label-icon--toggleable');
              labelIcon.setAttribute('aria-label', 'Ordner auf- oder zuklappen');
              labelIcon.setAttribute('title', 'Ordner auf- oder zuklappen');
              labelIcon.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                toggleNode(rowNode, node.id, labelIcon);
              });
            }

            const labelText = document.createElement('span');
            labelText.className = 'tree-label-text';
            labelText.textContent = node.name;
            label.appendChild(labelText);

            if (isGameNode) {
              label.classList.add('tree-label--play');
              label.setAttribute('aria-label', 'Spielseite oeffnen: ' + node.name);
            }
            label.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (isGameNode) {
                openPlayableFolder(node);
                return;
              }
              if (hasChildren) {
                if (openGenericFolder(node)) return;
                if (!openedFolderIds.includes(node.id)) {
                  toggleNode(rowNode, node.id, labelIcon);
                }
                return;
              }
              if (canOpenPlayable) {
                openPlayableFolder(node);
                return;
              }
            });
            treeMain.appendChild(label);
            row.appendChild(treeMain);

            rowNode.appendChild(row);

            const childContainer = document.createElement('div');
            childContainer.className = 'tree-children';
            if (Array.isArray(node.children) && node.children.length > 0) {
              buildTree(childContainer, node.children, level + 1, progressMap);
            }
            rowNode.appendChild(childContainer);

            container.appendChild(rowNode);
          });
        }

        function toggleNode(rowNode, id, iconNode) {
          const idx = openedFolderIds.indexOf(id);
          if (idx >= 0) {
            openedFolderIds.splice(idx, 1);
            rowNode.classList.add('tree-node--collapsed');
          } else {
            openedFolderIds.push(id);
            rowNode.classList.remove('tree-node--collapsed');
          }

          if (iconNode) {
            const node = findNodeById(rootTree, id);
            const collapsed = !openedFolderIds.includes(id);
            iconNode.textContent = folderEmoji(
              node || { isFolder: true, hasFiles: false, children: [] },
              collapsed
            );
          }

          saveState();
        }

        function hasFolderChild(node) {
          const children = node && Array.isArray(node.children) ? node.children : [];
          return children.some((child) => child && child.isFolder);
        }

        function isGameLaunchNode(node) {
          return (
            !!node &&
            node.isFolder &&
            !hasFolderChild(node) &&
            isPlayableFolder(node)
          );
        }

        function resolveNodeIconKind(node) {
          if (!node) return '';
          const direct = normalizeIconValue(node.icon);
          if (direct) return direct;
          return resolveFolderIcon(node.jsonRelPath, node.gameRelPath);
        }

        function resolveThemeFolderIcon(node) {
          if (!node || !node.isFolder) return '';
          const children = Array.isArray(node.children) ? node.children : [];
          const playableChildren = children.filter((child) => isGameLaunchNode(child));
          if (!playableChildren.length) return '';
          const hasFlame = playableChildren.some((child) => resolveNodeIconKind(child) === 'flame');
          return hasFlame ? 'flame' : 'books';
        }

        function resolveExamProbabilityStats(node) {
          if (!node || !node.isFolder) return { flame: 0, total: 0 };

          if (isGameLaunchNode(node)) {
            const isFlame = resolveNodeIconKind(node) === 'flame';
            return { flame: isFlame ? 1 : 0, total: 1 };
          }

          const children = Array.isArray(node.children) ? node.children : [];
          let flame = 0;
          let total = 0;
          for (let i = 0; i < children.length; i += 1) {
            const childStats = resolveExamProbabilityStats(children[i]);
            if (!childStats || typeof childStats !== 'object') continue;
            flame += Number(childStats.flame) || 0;
            total += Number(childStats.total) || 0;
          }

          if (total === 0 && isPlayableFolder(node)) {
            const ownFlame = resolveNodeIconKind(node) === 'flame' ? 1 : 0;
            return { flame: ownFlame, total: 1 };
          }

          return { flame: flame, total: total };
        }

        function resolveExamProbabilityPercent(node) {
          const stats = resolveExamProbabilityStats(node);
          if (!stats || typeof stats !== 'object') return 0;
          const total = Number(stats.total) || 0;
          if (total <= 0) return 0;
          const flame = Number(stats.flame) || 0;
          return clampPercent((flame / total) * 100);
        }

        function folderEmoji(node, isCollapsed) {
          const themeIcon = resolveThemeFolderIcon(node);
          if (themeIcon === 'flame') return 'üî•';
          if (themeIcon === 'books') return 'üìö';
          if (isGameLaunchNode(node)) return '';
          return isCollapsed ? 'üìÅ' : 'üìÇ';
        }

        function resolveFolderIcon(jsonRelPath, gameRelPath) {
          const source = String(gameRelPath || jsonRelPath || '');
          if (!source) return '';
          const sourceLower = source.toLowerCase();
          if (sourceLower.indexOf('/erschienene themen/') >= 0) return 'flame';
          if (sourceLower.indexOf('/vergangene themen/') >= 0) return 'flame';
          if (sourceLower.indexOf('/m√∂gliche themen/') >= 0 || sourceLower.indexOf('/mogliche themen/') >= 0) {
            return 'books';
          }
          return 'books';
        }

        function findNodeById(nodes, id) {
          for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            if (node.id === id) return node;
            if (node.isFolder && Array.isArray(node.children)) {
              const found = findNodeById(node.children, id);
              if (found) return found;
            }
          }
          return null;
        }

        function isPlayableFolder(node) {
          return (
            !!node &&
            node.isFolder &&
            !!node.hasFiles &&
            (!!node.jsonRelPath || !!node.gameRelPath || !!node.attributesRelPath)
          );
        }

        function openPlayableFolder(node) {
          if (!contentHost) return;
          const folderLabel = node && node.name ? node.name : 'Spielordner';
          const jsonRelPath = node && node.jsonRelPath
            ? String(node.jsonRelPath)
            : (node && node.attributesRelPath ? String(node.attributesRelPath) : '');
          const gameRelPath = node && node.gameRelPath ? String(node.gameRelPath) : '';
          const progressKey = buildNodeProgressKey(node);
          const jsonUrl = jsonRelPath ? buildRepoUrl(jsonRelPath) : '';
          const gameUrl = gameRelPath ? buildRepoUrl(gameRelPath) : '';
          if (gameUrl || jsonUrl) {
            openPracticeView(gameUrl, jsonUrl, folderLabel, progressKey);
            return;
          }
          openGenericFolder(node);
        }

        function hasOwnGenericContent(node) {
          return !!(
            node &&
            node.hasFiles &&
            (node.attributesRelPath || node.jsonRelPath || node.gameRelPath)
          );
        }

        function openGenericFolder(node) {
          if (!contentHost) return false;
          if (!hasOwnGenericContent(node)) return false;
          stopActiveGameProgressTracking();
          const folderLabel = node && node.name ? node.name : 'Thema';
          const sourceNode = node || {};
          const jsonRelPath = sourceNode && sourceNode.attributesRelPath
            ? String(sourceNode.attributesRelPath)
            : (sourceNode && sourceNode.jsonRelPath ? String(sourceNode.jsonRelPath) : '');
          const gameRelPath = sourceNode && sourceNode.gameRelPath ? String(sourceNode.gameRelPath) : '';
          const jsonUrl = jsonRelPath ? buildRepoUrl(jsonRelPath) : '';
          const gameUrl = gameRelPath ? buildRepoUrl(gameRelPath) : '';
          if (!jsonUrl && !gameUrl) return false;
          const src = buildGenericPageSrc(
            folderLabel,
            jsonUrl,
            gameUrl,
            jsonRelPath,
            gameRelPath,
            node && node.id ? node.id : ''
          );
          contentHost.innerHTML =
            '<iframe class="content-frame" src="' + src + '" title="Thema" loading="eager"></iframe>';
          queueThemeSyncForNewFrame();
          return true;
        }

        function buildGenericPageSrc(folderLabel, jsonUrl, gameUrl, jsonRelPath, gameRelPath, nodeId) {
          return (
            './generic_pages/generic_page.html?folder=' +
            encodeURIComponent(folderLabel) +
            '&json=' +
            encodeURIComponent(jsonUrl || '') +
            '&game=' +
            encodeURIComponent(gameUrl || '') +
            '&jsonRel=' +
            encodeURIComponent(jsonRelPath || '') +
            '&gameRel=' +
            encodeURIComponent(gameRelPath || '') +
            '&nodeId=' +
            encodeURIComponent(nodeId || '') +
            '&theme=' +
            encodeURIComponent(getCurrentTheme())
          );
        }

        function buildPracticeSrc(folderLabel, jsonUrl) {
          return (
            './generic_pages/generic_c_suite/generic_c_suite.html?folder=' +
            encodeURIComponent(folderLabel) +
            '&json=' +
            encodeURIComponent(jsonUrl) +
            '&theme=' +
            encodeURIComponent(getCurrentTheme())
          );
        }

        function openPracticeView(gameUrl, jsonUrl, folderLabel, progressKey) {
          if (!contentHost) return;
          const safeGameUrl = String(gameUrl || '').trim();
          let src = safeGameUrl || buildPracticeSrc(folderLabel || 'Spielordner', jsonUrl || '');
          if (safeGameUrl) {
            try {
              const url = new URL(safeGameUrl, window.location.href);
              url.searchParams.set('theme', getCurrentTheme());
              if (jsonUrl) url.searchParams.set('json', jsonUrl);
              src = url.href;
            } catch (_) {
              src = safeGameUrl;
            }
          }
          contentHost.innerHTML =
            '<iframe class="content-frame" src="' + src + '" title="C-Suite Prototyp" loading="eager"></iframe>';
          queueThemeSyncForNewFrame();
          const resolvedProgressKey = normalizeProgressKey(progressKey || inferProgressKeyFromUrls(gameUrl, jsonUrl));
          if (resolvedProgressKey) {
            startActiveGameProgressTracking(resolvedProgressKey);
          } else {
            stopActiveGameProgressTracking();
          }
        }

        function findAttributesRelPath(children) {
          const files = Array.isArray(children) ? children : [];
          const matches = [];

          function collectAttributeFiles(nodes) {
            const list = Array.isArray(nodes) ? nodes : [];
            for (let i = 0; i < list.length; i += 1) {
              const child = list[i];
              if (!child) continue;
              if (child.isFolder) {
                collectAttributeFiles(child.children);
                continue;
              }
              const kind = String(child.kind || '').toLowerCase();
              const name = String(child.name || '').toLowerCase();
              if ((kind === 'json' || name.endsWith('.json')) && /^__(metadata|gattributes)_.+\.json$/i.test(name) && child.relPath) {
                matches.push(child.relPath);
              }
            }
          }

          collectAttributeFiles(files);
          const preferred = matches.find((relPath) => /\/__02_doing_/i.test(String(relPath)));
          return preferred || matches[0] || '';
        }

        function findFirstJsonRelPath(children) {
          const preferredGameFiles = [];
          const otherJsonFiles = [];
          const files = Array.isArray(children) ? children : [];

          function collectJsonFiles(nodes) {
            const list = Array.isArray(nodes) ? nodes : [];
            for (let i = 0; i < list.length; i += 1) {
              const child = list[i];
              if (!child) continue;
              if (child.isFolder) {
                collectJsonFiles(child.children);
                continue;
              }
              const kind = String(child.kind || '').toLowerCase();
              const name = String(child.name || '').toLowerCase();
              if ((kind === 'json' || name.endsWith('.json')) && child.relPath) {
                if (/^__(metadata|gattributes)_.+\.json$/i.test(name)) {
                  continue;
                }
                if (/^_g+\d+.*\.json$/i.test(name) || /^game_.+\.json$/i.test(name)) {
                  preferredGameFiles.push(child.relPath);
                } else {
                  otherJsonFiles.push(child.relPath);
                }
              }
            }
          }

          collectJsonFiles(files);
          if (preferredGameFiles.length) return preferredGameFiles[0];
          if (otherJsonFiles.length) return otherJsonFiles[0];
          return '';
        }

        function findGameHtmlRelPath(children) {
          const files = Array.isArray(children) ? children : [];
          const htmlFiles = [];

          function collectHtmlFiles(nodes) {
            const list = Array.isArray(nodes) ? nodes : [];
            list.forEach(function (child) {
              if (!child) return;
              if (child.isFolder) {
                collectHtmlFiles(child.children);
                return;
              }
              const kind = String(child.kind || '').toLowerCase();
              const name = String(child.name || '').toLowerCase();
              if (kind === 'html' || name.endsWith('.html')) {
                htmlFiles.push(child);
              }
            });
          }

          collectHtmlFiles(files);

          const preferred = htmlFiles.find(function (child) {
            const name = String(child.name || '').toLowerCase();
            return name.startsWith('_ghtml_') || name.startsWith('game_');
          }) || htmlFiles[0];

          return preferred && preferred.relPath ? preferred.relPath : '';
        }

        function escapeHtml(value) {
          return String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        }
      })();
    </script>
  </body>
</html>
